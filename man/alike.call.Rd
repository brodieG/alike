% Generated by roxygen2 (4.0.1): do not edit by hand
\name{alike.call}
\alias{alike.call}
\alias{alike.call,}
\alias{alike.expression}
\alias{alike.formula,}
\title{Alike Methods For Calls, Formulas, and Expressions}
\usage{
\method{alike}{call}(obj.reference, obj, int.strict = 0L,
  class.mode = "common.ancestry", special.attrs = TRUE, all.attrs = FALSE,
  exclude.parens = TRUE, ...)
}
\arguments{
\item{exclude.parens}{if TRUE will remove parens before comparing (note this does
not affect operator priority since parens are removed after parsing), which means
calls that are equivalent and only different due to parense (e.g
\code{(1 + 1)} vs \code{1 + 1L}) will not be considered different}

\item{obj.reference}{an R object}

\item{obj}{an R object}

\item{int.strict}{1 length int in \code{`0:2`} (see "Low Level Comparisons" in details)}

\item{class.mode}{1 length character, one of c("common.ancestry", "equal")
(see \code{`class_alike`} section in details)}

\item{special.attrs}{1 length logical (see \code{`attributes_alike`} section
in details)}

\item{all.attrs}{1 length logical (see \code{`attributes_alike`} section
in details)}

\item{...}{arguments to pass on to \code{`comp.fun`}}
}
\value{
TRUE if alike, character string describing first discrepancy otherwise
}
\description{
These functions attempt to hew to the spirit of \code{`\link{alike}`}
by comparing structure rather than contents of \code{`obj.reference`}
and \code{`obj`}.  Exactly what is considered \dQuote{structure} rather than
\dQuote{contents} varies with each method.
}
\details{
As with the other \code{`\link{alike}`} functions, alikeness is complex
to describe, but is generally intuitive expressed in the examples.
}
\section{\code{`alike.formula`}}{


Formulas are considered alike if they contain all the same calls
and the same constants in the same slots.  Variable names need not be
the same, but they must be consistent.

See examples.
}

\section{\code{`alike.call`}}{


\code{`obj`} calls are considered alike to \code{`obj.reference`} calls
if every call and nested call contained in \code{`obj.reference`} exists
in \code{`obj`}.  Additionally, every call and sub-call must have the
same structure (i.e. same number of arguments).

Constants and variables within calls or sub-calls need not match,
and if \code{`obj.reference`} contains a constant or variable in a
particular position, \code{`obj`} may contain anything in that position,
including a call.  However, if \code{`obj.reference`} contains a call in a
particular position, then \code{`obj`} must also contain a call to the same
function in that position.

If a call involves a function defined in the calling environment, then
the call will be re-arranged with \code{`\link{match.call}`} before
comparison.

See examples.
}

\section{\code{`alike.expression`}}{


Expressions are considered alike if they contain the same number of subobjects,
and if each subobject is \code{`\link{alike}`}.

Note that attributes \dQuote{srcref}, \dQuote{srcfile}, and \dQuote{wholeSrcref}
are ignored in the comparison as otherwise the comparisons would fail on those
attributes rather than diving into the expressions and detailing the failure
point.
}
\examples{
alike(x ~ y, z ~ w)                # TRUE
alike(x ~ y, z ~ w + 1)            # Incorrect
alike(x ~ y + 2, z ~ w + 1)        # Incorrect; constants must be equal
alike(x ~ y + z:y, w ~ v + u:v)    # TRUE, var names consistent

alike(quote(1 + 1), quote(x + y))                 # TRUE
alike(quote(fun(1 + 1)), quote(fun(x + y, 9)))    # Nope, structures not the same
alike(quote(fun(b=fun2(x, y), 1, 3)), quote(fun(NULL, fun2(a, b), 1)))  # Nope, not using same named args
fun <- function(a, b, c) NULL      # define `fun`
alike(quote(fun(b=fun2(x, y), 1, 3)), quote(fun(NULL, fun2(a, b), 1)))  # TRUE, Because fun defined, uses match.call() to re-arrange args so it works
}
\seealso{
alike
}

