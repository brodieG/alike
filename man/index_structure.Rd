% Generated by roxygen2 (4.0.1): do not edit by hand
\name{index_structure}
\alias{extract_with_index}
\alias{extract_with_indices}
\alias{index_structure}
\title{Recursively Extract Elements and Indeces From List}
\usage{
index_structure(x, terminal.nodes.only = TRUE, recurse.exclude = function(y)
  FALSE, ...)
}
\arguments{
\item{x}{the recursive object to generate indeces for}

\item{terminal.nodes.only}{set to FALSE if you want all intermediate recursive
objects in addition to the "leaves" of the recursive structure (see examples).
Be careful with this setting if you are dealing with a recursive structure
containing large objects as this could lead to the large object being copied
many, many times over.}

\item{recurse.exclude}{function that will evaluate whether an element of \code{`x`}
should be recursed into or not, should accept only one argument}

\item{index.list}{a list of "recursive" index vectors as produced by \code{`index_structure`}}

\item{index}{a "recursive" index as contained in \code{`index.list`}}

\item{...}{included for compatibility with future methods}
}
\value{
\itemize{
  \item for \code{`index_structure`}, a list of "recursive" index vectors (numeric vectors
    of class "recursive_index") for every object in \code{`x`}.  The list will inherit
    from "recursive_index_list", and also from either "recursive_terminal_index_list"
    or "recursive_full_index_list" depending on the value of \code{`terminal.nodes.only`}).
  \item for \code{`extract_with_index`} and \code{`extract_with_indeces`}, the extracted
    object or a list of extracted objects, respectively
}
}
\description{
\code{`index_structure`} produces a list with a vector for every object in \code{`x`},
where each vector contains the indeces required to extract the corresponding object
from \code{`x`}.  For example, in:
\code{
lst <- list(1, 2, list(1:3, "hello"))
}
the vector corresponding to "hello" would be c(3L, 2L) because
\code{
lst[[3L]][[2L]] == "hello"
}
These index vectors are "recursive" index vectors, not index vectors to use with
\code{`\link{[}`}.
}
\details{
By default \code{`index_structure`} will return "recursive" indeces only for
terminal nodes.  Zero length recursive structures will be treated as terminal
nodes (e.g., in \code{list(1, list(), 3)}, the second element is considered
terminal).  You can get all intermediate objects indeces as well with
\code{`terminal.nodes.only`=FALSE}.

\code{`extract_with_indices`} will extract items from lists using the recursive index
vectors produced by \code{`index_structure`} (see examples for more details). This
essentially results in a "flat" list, though it is not the same as what you
get with a simple application of \code{`\link{rapply}`} or \code{`\link{unlist}`}
because vectors are not collapsed together (e.g. \code{list(1:3, letters[5:7]))} is
considered flat and won't be simplified further).

The flattening process is implemented as two separate functions rather than
just a single function because the intermediate list of "recursive"
index vectors captures the structure of \code{`x`}, whereas the flat list only
captures its values (i.e. values only wouldn't distinguish between
\code{list(list("a", "b"), "c")}) and \code{list("a", "b", "c")}.

If you only wish to extract one item from the list use \code{`extract_with_index`}.

\code{`index_structure`} is implemented as an S3 generic, with methods available
for lists and calls. \code{`extract_with_indices`} and \code{`extract_with_index`}
are also generic, although at the time of this writing only the default method
is implemented (and will work with both lists and calls).

\code{`\link{alike}`} methods are implemented for recursive indeces in
package.
}
\note{
can probably be optimized quite a bit in terms of performance, but jury's
  out on whether this is necessary (probably will be, TBD).  Main performance
  improvement would come from sizing list for index vectors ahead of time and
  populating it with <<- (as per stack overflow answer to flatten/rapply list Q.)
}
\examples{
lst <- list(list(1L, "a"), TRUE, data.frame(nums=1L:3L, alfs=letters[5L:7L]))

index_structure(lst)
extract_with_indices(lst, index_structure(lst))   # data.frame is a list, so it is recursed
extract_with_indices(lst, index_structure(lst, terminal.nodes.only=FALSE))  # can also see intermediate objects
extract_with_indices(lst, index_structure(lst, terminal.nodes.only=FALSE, recurse.exclude=is.data.frame))  # and not recurse into data.frames
try(extract_with_indices(lst, c(5, index_structure(lst, terminal.nodes.only=FALSE, recurse.exclude=is.data.frame))))  # testing error handling

call <- quote(sum(1:3)/mean(1:3))
extract_with_indices(call, index_structure(call))
extract_with_indices(call, index_structure(call, terminal.nodes.only=FALSE))
}
\seealso{
\code{`\link{terminal_indices}`}, \code{`\link{is.recursive_index}`}
}

