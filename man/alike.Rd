% Generated by roxygen2 (4.0.2): do not edit by hand
\name{alike}
\alias{alike}
\title{Compare Object Structure}
\usage{
alike(target, current, int.mode = 0L, int.tol = MachDblEpsSqrt,
  attr.mode = 0L)
}
\arguments{
\item{target}{the template to compare the object to}

\item{current}{the object to determine alikeness to the template}

\item{int.mode}{integer(1L) in 0:2, see \code{`mode`} parameter to \code{`\link{type_alike}`}}

\item{int.tol}{numeric(1L) see \code{`tolerance`} paramter to \code{`\link{type_alike}`}}

\item{attr.mode}{integer(1L) in 0:2 determines strictness of attribute comparison, see details}
}
\value{
TRUE if target and current are alike, character(1L) describing why they are not if they are not
}
\description{
Similar to \code{`\link{all.equal}`}, but compares object structure rather than
value.
}
\details{
Exactly what makes two objects \code{`alike`} is complex to explain in words,
but should be clear from the examples.  We recommend you review those.  If you
are interested in more details, see the vignette.
}
\section{Length Comparisons}{


Generally speaking the lengths of two objects must be equal in order for them
to be considered alike, though in the special case where \code{`target`} is
length zero, then \code{`current`} may be any length.
}

\section{Types}{


The underlying data types between two objects must be \code{`\link{type_alike}`}.
}

\section{Attribute Comparison}{


Generally speaking attributes between \code{`target`} and \code{`current`}
must be identical, but there are some exceptions:

Paramter \code{`attr.mode`} controls how attributes are compared:
\itemize{
  \item 0: special attributes are compared specially, and only attributes
    present in \code{`target`} are compared (i.e. \code{`current`} may have
    additional attributes).  Special attributes include:
    \itemize{
      \item \code{`dim`}, \code{`dimnames`}, \code{`row.names`}, and \code{`names`}
      \item \code{`class`}
      \item zero-length attributes
      \item reference attributes (e.g. external pointers environments, etc.)
    }
  \item 1: all attributes present in \code{`target`} must be present in
    \code{`current`} and be identical.
  \item 2: all attributes present in \code{`target`} must be present in
    \code{`current`} and there may be no additional attributes in \code{`current`}
}
Please see vignette for details on for how special attributes are compared.
Note that attributes on attributes (e.g. \code{`names(dimnames(x))`}) are
generally required to be identical in \code{`target`} and \code{`current`},
though \code{`names(dimnames(x))`} itself is a special case.
}

\section{\code{`.alike`}}{


\code{`.alike`} is identical to \code{`alike`}, except that it doesn't accept
any parameters outside of \code{`target`} and \code{`current`}, and as a result
is slightly faster.
}
\examples{
alike(1L, 1.0)         # TRUE, because 1.0 is integer-like
alike(1L, 1.1)         # FALSE, 1.1 is not integer-like
alike(1.1, 1L)         # TRUE, by default, integers are always considered real
alike(integer(), 1:4)  # TRUE, Zero length `target` matches any length `current`
alike(1:4, integer())  # But not vice versa

# Scalarness can now be checked at same time as type

x <- 1
x.2 <- 1:3
y <- TRUE
y.2 <- c(TRUE, TRUE)

alike(integer(1L), x)
alike(logical(1L), y)
alike(integer(1L), x.2)
alike(logical(1L), y.2)

# `alike` will compare data frame columns

df.tpl <- data.frame(id=integer(), grade=factor(levels=LETTERS[1:6]))
df.cur <- data.frame(id=c(1, 3, 5), grade=factor(c("A", "F", "B"), levels=LETTERS[1:6]))
df.cur2 <- data.frame(id=c(1, 3, 5), grade=c("A", "F", "B"))

alike(df.tpl, df.cur)    # zero row df as `target` matches any length df
alike(df.cur, df.tpl)    # alike is not "commutative", now `target` is not zero row

# factor levels must match; makes sense, otherwise it really isn't the same
# type of data (note this is a recursive comparison); for better understanding
# of error examine `levels(df.tpl[[2]])` and `levels(df.cur2[[2]])`

alike(df.tpl, df.cur2)

alike(list(integer(), df.tpl), list(1:4, df.cur))  # recursive comparison
alike(matrix(integer(), 3), matrix(1:21, ncol=7))  # partially specified dimensions

# In order for objects to be alike, they must share a family tree, not just
# a common class

obj.tpl <- structure(TRUE, class=letters[1:3])
obj.cur.1 <-  structure(TRUE, class=c("x", letters[1:3]))
obj.cur.2 <-  structure(TRUE, class=c(letters[1:3], "x"))

alike(obj.tpl, obj.cur.1)
alike(obj.tpl, obj.cur.2)
}
\seealso{
type_alike, type_of
}

