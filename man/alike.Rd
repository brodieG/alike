% Generated by roxygen2 (4.0.2): do not edit by hand
\name{alike}
\alias{alike}
\title{Compare Object Structure}
\usage{
alike(target, current, int.mode = 0L, int.tol = MachDblEpsSqrt,
  attr.mode = 0L)
}
\arguments{
\item{target}{the template to compare the object to}

\item{current}{the object to determine alikeness to the template}

\item{int.mode}{integer(1L) in 0:2, see \code{mode} parameter to \code{\link{type_alike}}}

\item{int.tol}{numeric(1L) see \code{tolerance} paramter to \code{\link{type_alike}}}

\item{attr.mode}{integer(1L) in 0:2 determines strictness of attribute comparison, see details}
}
\value{
TRUE if target and current are alike, character(1L) describing why they are not if they are not
}
\description{
Similar to \code{\link{all.equal}}, but compares object structure rather than
value.  The \code{target} argument defines a template that the \code{current}
argument must match.
}
\details{
Exactly what makes two objects \code{alike} is complex, but should be
intuitive.  The best way to understand "alikenes" is to review the examples.
If you are interested in more details, see the vignette.
}
\section{Value Comparisons}{


Values are never compared explicitly by \code{alike}.
}

\section{Length Comparisons}{


The lengths of two objects must be equal in order for them to be considered
alike, though in the special case where \code{target} is length zero, then
\code{current} may be any length..
}

\section{Types}{


The underlying data types between two objects must be \code{\link{type_alike}}.
}

\section{Attribute Comparison}{


Generally speaking attributes between \code{target} and \code{current}
must be identical, but there are some exceptions:

Paramter \code{attr.mode} controls how attributes are compared:
\itemize{
  \item 0: special attributes are compared specially, and only attributes
    present in \code{target} are compared (i.e. \code{current} may have
    additional attributes).  Special attributes include:
    \itemize{
      \item \code{dim}, \code{dimnames}, \code{row.names}, and \code{names}
      \item \code{class}
      \item zero-length attributes
      \item reference attributes (e.g. external pointers environments, etc.)
    }
  \item 1: all attributes present in \code{target} must be present in
    \code{current} and be identical.
  \item 2: attributes in \code{target} and \code{current} must be identical
}
Please see vignette for details on for how special attributes are compared.
Note that attributes on attributes (e.g. \code{names(dimnames(x))}) are
generally required to be identical in \code{target} and \code{current},
though \code{names(dimnames(x))} itself is a special case.
}

\section{\code{.alike}}{


\code{.alike} is identical to \code{alike}, except that it doesn't accept
any parameters outside of \code{target} and \code{current}, and as a result
is slightly faster.
}
\examples{
alike(1L, 1.0)         # TRUE, because 1.0 is integer-like
alike(1L, 1.1)         # FALSE, 1.1 is not integer-like
alike(1.1, 1L)         # TRUE, by default, integers are always considered real
alike(integer(), 1:4)  # TRUE, Zero length `target` matches any length `current`
alike(1:4, integer())  # But not vice versa

# Scalarness can now be checked at same time as type

x <- 1
x.2 <- 1:3
y <- TRUE
y.2 <- c(TRUE, TRUE)

alike(integer(1L), x)
alike(logical(1L), y)
alike(integer(1L), x.2)
alike(logical(1L), y.2)

# Zero length match any length of same type

alike(integer(), 1:10)

# NULL matches anything

alike(NULL, mtcars)
alike(list(NULL, NULL), list(iris, mtcars))

# `alike` will compare data frame columns

df.tpl <- data.frame(id=integer(), grade=factor(levels=LETTERS[1:6]))
df.cur <- data.frame(id=c(1, 3, 5), grade=factor(c("A", "F", "B"), levels=LETTERS[1:6]))
df.cur2 <- data.frame(id=c(1, 3, 5), grade=c("A", "F", "B"))

alike(df.tpl, df.cur)    # zero row df as `target` matches any length df
alike(df.cur, df.tpl)    # alike is not "commutative", now `target` is not zero row

# factor levels must match; makes sense, otherwise it really isn't the same
# type of data (note this is a recursive comparison); for better understanding
# of error examine `levels(df.tpl[[2]])` and `levels(df.cur2[[2]])`

alike(df.tpl, df.cur2)

alike(list(integer(), df.tpl), list(1:4, df.cur))  # recursive comparison
alike(matrix(integer(), 3), matrix(1:21, ncol=7))  # partially specified dimensions

# In order for objects to be alike, they must share a family tree, not just
# a common class

obj.tpl <- structure(TRUE, class=letters[1:3])
obj.cur.1 <-  structure(TRUE, class=c("x", letters[1:3]))
obj.cur.2 <-  structure(TRUE, class=c(letters[1:3], "x"))

alike(obj.tpl, obj.cur.1)
alike(obj.tpl, obj.cur.2)
}
\seealso{
type_alike, type_of
}

