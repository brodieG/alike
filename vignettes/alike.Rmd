---
title: "alike"
author: "Brodie Gaslam"
output:
    rmarkdown::html_vignette:
        toc: true
        css: styles.css

vignette: >
  %\VignetteIndexEntry{alike}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---

## Introduction

`alike` is similar to `all.equal` from base R, except it focuses on comparing object structure rather than actual values:

```{r}
library(alike)
alike(integer(), 1:5)
alike(integer(), letters[1:5])
alike(integer(4), 1:5)
alike(integer(5), 1:5)
```
`alike` only compares the structure of the objects (e.g. type, length, class, attributes, etc.), which is how we can match `1:5` to `integer(5)` even though these have clearly different values.

`alike` will also compare recursive structures element by element, which allows things such as:

```{r}
df.tpl <- data.frame(id=integer(), grade=factor(levels=LETTERS[1:6]))
df.correct <- data.frame(id=1:3, grade=factor(c("F", "A", "C"), levels=LETTERS[1:6]))
df.wrong <- data.frame(id=4:6, grade=c("F", "A", "C"))

alike(df.tpl, df.correct)
alike(df.tpl, df.wrong)
```
`alike` will be used in `validate` to provide a template based mechanism for validating user inputs to functions, but can be used in any place that verifying object structure is useful.

The rules governing what makes objects alike are complex to explain, but should result in intuitive outcomes.  We recommend you look at the examples in the documentation for `alike` to get a sense for how `alike` works.  If you want to understand the specifics, read on.

## Templates

### Overview

The basic concept behind `alike` is to allow the user to define templates to use as the `target` argument to compare against the `current` argument.  Templates can specify as little or as much structure as desired, and `alike` will only compare the object against the aspects of the template that are defined.  This is how we are able to define our matrix template in the introduction that only checks for the number of columns in an object.

One implication of this is that `alike` is not "commutative".  Compare the following to our previous examples:

```{r}
alike(matrix(integer(), nrow=3), matrix(1:12, ncol=4))
alike(matrix(1:12, ncol=4), matrix(integer(), nrow=3))   # reverse args
```

Our template now defines a non-zero length object so `current` must match its length.

### Structure Wildcards

In addition to zero length `target` matching any length `current`, any `NULL` values nested in `target` will match anything at all in current, but if `target` is `NULL` then current must be `NULL`:

```{r}
alike(integer(), 1:10)               # zero length matches any length of same type
alike(NULL, mtcars)                  # NULL only matches NULL
alike(list(NULL), list(mtcars))      # but inside a list, NULL matches anything
alike(list(), list(1:10, mtcars, iris))      # zero length list matches any list
alike(list(NULL, NULL), list(1:10, mtcars))  # two NULLs match two length list
alike(list(NULL, NULL), list(1:10, mtcars, iris))   # but not three length list
```

Treating `NULL` differently depending on whether it is nested or not is a compromise designed to make `alike` a better fit for argument validation.  Arguments that are `NULL` by default are fairly common, so it is useful for `alike` to be able to determine whether something is `NULL`.  At the same time, we need some mechanism for specifying arbitrary contents in lists of fixed length, so we allow `NULL` to act as a wildcard when nested inside other objects.  This inconsistent treatment is rendered necessary by `NULL` being both a type and a zero length value (or a value-less type).

## Comparison Details

### Overview

`alike` will compare the internal types of objects (see `base::typeof`), their lengths, and their attributes.  Generally speaking objects are considered alike if they are of the same type, length, and have identical attributes, though there are exceptions we will discuss later.

`alike` will recurse through lists and do pairwise alikeness comparisons between the corresponding elements of the `target` and `current` lists.  Among other things, this means that `alike` will compare the structures of the component vectors of `data.frame` as these are lists.

### Length Comparison

`target` and `current` object lengths must be the same, unless the `target` object has length zero, in which case the `current` object can have any length.  If your template does not need to restrict the length of an object then you would use a zero length element as the `target` object.  Note the implication here is that you cannot create a template that requires the `current` object to have length zero, but this should be a rare requirement.

### Type Comparison

#### Overview

Type comparison is done as if it were done using `typeof` with the notable exception that numerics, integers, and functions are treated specially.

#### Numerics / Integer

```{r}
alike(1L, 1)     # note 1 is not integer
is.integer(1)
alike(1L, 1.1)   # 1.1 is not integer-like
alike(1.1, 1L)   # but integers can match numerics
```
`alike` treats integer-like numerics as integers.  Additionally, integers can match numeric templates.  While this feature may seem superfluous it avoids convolutions such as:
```{r, eval=FALSE}
is.numeric(x) && all.equal(x, floor(x))
```

#### Functions

All three types of functions (closures, builtins, and specials) are treated as the same type.

#### Forcing Strict comparisons

You can remove this loose type comparison functionality with by changing the `type.mode` value to be stricter.  See documentation for `mode` parameter of `type_of`.

### Attribute Comparison

#### Overview

Attributes present in `target` must be present in `current`, but `current` may have additional attributes not present in `target`.  The attributes that overlap must be `identical`, with some important exceptions outlined below. You can engage stricter comparison modes with the `attr.mode` parameter.  Note that length zero attributes in `target` do not match arbitrary length attributes in `current` except as detailed below.

#### `row.names` and `names`

If present in `target`, then must be matched exactly by the corresponding attribute in `current`, except that:

* zero length character values (i.e. `""`) in `target` `names`/`row.names` will match any character value in the corresponding position of the `current` `names`/`row.names`
* zero length `target` attribute (i.e. `character(0L)`, contrast to above) will match any character `names`/`row.names`

These exceptions are necessary to allow you to partially specify names and dimensions:
```{r}
# we use `structure` to circumvent default data.frame names
df.tpl <- structure(list(id=integer(), numeric(), numeric()), class="data.frame")
df.dat1 <- data.frame(id=1:3, x=runif(3), y=runif(3))
df.dat2 <- data.frame(bogus=1:3, x=runif(3), y=runif(3))

alike(df.tpl, df.dat1)
names(df.tpl)
names(df.dat1)
rownames(df.tpl)
rownames(df.dat1)

alike(df.tpl, df.dat2)
```

#### `dim`

`dim` attributes must be identical between `target` and `current`, except that if a value of the `dim` vector is zero in `target` then the corresponding value in `current` can be any value.  This is how comparisons like the following succeed:

```{r}
mx.tpl <- matrix(integer(), ncol=3);
mx.cur <- matrix(1:12, nrow=4)
mx.cur2 <- matrix(1:12, nrow=3)
alike(mx.tpl, mx.cur)

dim(mx.tpl)    # notice the 0 for the first value in the `dim` vector
dim(mx.cur)

alike(mx.tpl, mx.cur2)
```

#### `dimnames`

Must also be identical, except that if the `target` value of the `dimnames` list for a particular dimension is `NULL`, then the corresponding `dimnames` value in `current` may be anything.

Note that `dimnames` itself can also have a `names` attribute.  If the `names` attribute to `dimnames` is specified in `target`, then it must be identical in `current`, with the exception that zero length character values (i.e. `""`) in `target` will match any string in the corresponding name in `target`:

```{r}
mx.tpl <- matrix(integer(), ncol=3, dimnames=list(row.id=NULL, c("R", "G", "B")))
mx.cur <- matrix(sample(0:255, 12), ncol=3, dimnames=list(row.id=1:4, rgb=c("R", "G", "B")))
mx.cur2 <- matrix(sample(0:255, 12), ncol=3, dimnames=list(1:4, c("R", "G", "B")))

alike(mx.tpl, mx.cur)
alike(mx.tpl, mx.cur2)
names(dimnames(mx.tpl))
```

#### `class`

S3 objects are considered alike if the `current` class inherits from the `target` class.  Note that "inheritance" here is used in a stricter context than in the typical S3 application:

* Every class present in `target` must be present in `current`
* The overlapping classes must be in the same order
* The last class in `current` must be the same as the last class in `target`

To illustrate:

```{r}
tpl <- structure(NULL, class=c("a", "b", "c"))
cur <- structure(NULL, class=c("x", "a", "b", "c"))
cur2 <- structure(NULL, class=c("a", "b", "c", "x"))

alike(tpl, cur)
alike(tpl, cur2)
```

#### S4 and Reference Class (R5) Objects

S4 and RC objects are considered alike if `current` inherits from `class(target)`.

#### Reference Objects

Attributes containing objects of the following types are actually references to specific memory locations and as such are treated specially:

* Environments
* External Pointers
* Weak References
* Byte codes

Because `identical` will return `FALSE` if the objects don't point to the same memory location, even if they are technically equivalent, we only require that `target` and `current` be of the same type in order to meet the `alike` requirements.  This isn't ideal, but should lead to reasonable results in most circumstances.

If you want these attributes to be comapred with `identical` set `attr.mode` to 1 or 2.

## Objects That Might Be Treated Differently in Future

The following object types are not handled specially by alike, but might be in the future:

* Language objects (calls)
* Expressions
* Formulas

Currently they are compared purely on length and internal type.

## `alike` as an S3 generic

`alike` is not currently an S3 generic, but will likely become one in the future provided we can create an implementation with and acceptable performance profile.

## Performance Considerations

### Overview

`alike` is implemented in C and is relatively fast:

```{r}
library(microbenchmark)
microbenchmark(
  all.equal(1:10, 1:10),
  identical(1:10, 1:10),
  alike(1:10, 1:10),
  all.equal(mtcars, mtcars),
  identical(mtcars, mtcars),
  alike(mtcars, mtcars)
)
```

`identical` will pull ahead with more complex objects, but `alike` should remain substantially faster than `all.equal`.

### `.alike`

`.alike` does not accept any parameters outside of `target` and `current`, but as a result is slightly faster than `alike`:

```{r}
library(microbenchmark)
microbenchmark(
  alike(1:10, 1:10),
  .alike(1:10, 1:10)
)
```

You should use `.alike` if you don't require access to the other `alike` parameters and if you're looking to minimize overhead, but keep in mind the difference is pretty small.

### Pre-defining Templates

Some fairly innocuous R expressions carry substantial overhead.  Consider:

```{r}
df.tpl <- data.frame(integer(), numeric())
df.cur <- data.frame(a=1:10, b=1:10 + .1)

library(microbenchmark)
mb <- microbenchmark(
  alike(df.tpl, df.cur),
  alike(data.frame(integer(), numeric()), df.cur)
)
summary(mb)[1:4]
```

`data.frame` is a particularly slow constructor, but in general you are best served by defining your templates outside of your function if you want to keep things at their snappiest.
